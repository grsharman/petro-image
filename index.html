<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenSeaDragon Split View Example</title>
    <style>
        body, html {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        #viewer-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #viewer {
            position: absolute;
            height: 100%;
            width: 100%;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/OpenSeadragonScalebar/2.0.0/openseadragon-scalebar.min.css" />
</head>
<body>
    <div id="viewer-container"></div>
    <script src="js/openseadragon.min.js"></script>
    <script src="js/openseadragon-scalebar.min.js"></script>
    <script>
        const viewer = OpenSeadragon({
            id: "viewer-container",
            prefixUrl: "js/images/",
            tileSources: [
                "https://raw.githubusercontent.com/grsharman/petro-image/main/images/O48-013.dzi",
                "https://raw.githubusercontent.com/grsharman/petro-image/main/images/O48-014.dzi",
                "https://raw.githubusercontent.com/grsharman/petro-image/main/images/O48-013.dzi",
            ]
        });

        const viewerContainer = document.getElementById('viewer-container');

        // Share mouse position and division point data between different event
        // handlers.
        let mousePos = null;
        let divisionPoint = new OpenSeadragon.Point(0, 0);

        // Divides the images at the current division point (either the mouse
        // position or the center of the window), clipping overlaid images to
        // expose the images underneath. Note that all images are expected to
        // have the same position and size.
        const divideImages = () => {
            divisionPoint = mousePos || new OpenSeadragon.Point(document.body.clientWidth / 2, document.body.clientHeight / 2);

            const overlay1 = viewer.world.getItemAt(1);
            const overlay2 = viewer.world.getItemAt(2);
            const clipPos = overlay1.viewerElementToImageCoordinates(divisionPoint);

            // Clamp the clip point to within the image bounds.
            const size = overlay1.getContentSize();
            const xClip = Math.max(0, Math.min(clipPos.x, size.x));
            const yClip = Math.max(0, Math.min(clipPos.y, size.y));

            // Set clips.
            overlay1.setClip(new OpenSeadragon.Rect(0, 0, xClip, yClip));
            overlay2.setClip(new OpenSeadragon.Rect(xClip, 0, size.x, yClip));
        };

        viewer.addHandler('animation', divideImages);

        viewer.addHandler('update-viewport', () => {
            // Draw lines dividing the images, directly on the viewer's canvas.

            // This is gnarly, but I don't know that there's a better way to
            // find the window-space bounds of a viewer image.
            const image0 = viewer.world.getItemAt(0);
            const topLeftViewport = image0.viewportToImageCoordinates(image0.getBounds().getTopLeft())
            const topLeftWindow = image0.imageToWindowCoordinates(topLeftViewport);
            const bottomRightViewport = image0.viewportToImageCoordinates(image0.getBounds().getBottomRight());
            const bottomRightWindow = image0.imageToWindowCoordinates(bottomRightViewport);
            const top = Math.ceil(topLeftWindow.y);
            const bottom = Math.floor(bottomRightWindow.y);
            const left = Math.ceil(topLeftWindow.x);
            const right = Math.floor(bottomRightWindow.x);

            const ctx = viewer.drawer.context;
            ctx.lineWidth = 2;
            if (divisionPoint.y >= top && divisionPoint.y <= bottom) {
                ctx.beginPath();
                ctx.moveTo(left, divisionPoint.y);
                ctx.lineTo(right, divisionPoint.y);
                ctx.stroke();
            }
            if (divisionPoint.x >= left && divisionPoint.x <= right && divisionPoint.y >= top) {
                ctx.beginPath();
                ctx.moveTo(divisionPoint.x, top);
                ctx.lineTo(divisionPoint.x, Math.min(divisionPoint.y, bottom));
                ctx.stroke();
            }
        });

        viewerContainer.addEventListener('pointermove', event => {
            mousePos = new OpenSeadragon.Point(event.clientX, event.clientY)
            divideImages();
        });
        document.addEventListener('mouseleave', () => {
            mousePos = null;
            divideImages();
        });

        // Adding scalebar to viewer
        viewer.scalebar({
            type: OpenSeadragon.ScalebarType.MAP,
            pixelsPerMeter: 100000, // Adjust according to your image
            minWidth: "75px",
            location: OpenSeadragon.ScalebarLocation.BOTTOM_LEFT,
            xOffset: 10,
            yOffset: 10,
            stayInsideImage: true,
            color: "black",
            fontColor: "black",
            backgroundColor: "rgba(255, 255, 255, 0.5)",
            fontSize: "small",
            barThickness: 2
        });
    </script>
</body>
</html>
